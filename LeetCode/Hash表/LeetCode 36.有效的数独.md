## LeetCode 36.有效的数独
### 题目
判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

数独部分空格内已填入了数字，空白格用 '.' 表示。

### 示例1
```markdown
输入：
[
 ["5","3",".",".","7",".",".",".","."],
 ["6",".",".","1","9","5",".",".","."],
 [".","9","8",".",".",".",".","6","."],
 ["8",".",".",".","6",".",".",".","3"],
 ["4",".",".","8",".","3",".",".","1"],
 ["7",".",".",".","2",".",".",".","6"],
 [".","6",".",".",".",".","2","8","."],
 [".",".",".","4","1","9",".",".","5"],
 [".",".",".",".","8",".",".","7","9"]
]
输出: true
```
### 示例2
```markdown
输入：
[
 ["8","3",".",".","7",".",".",".","."],
 ["6",".",".","1","9","5",".",".","."],
 [".","9","8",".",".",".",".","6","."],
 ["8",".",".",".","6",".",".",".","3"],
 ["4",".",".","8",".","3",".",".","1"],
 ["7",".",".",".","2",".",".",".","6"],
 [".","6",".",".",".",".","2","8","."],
 [".",".",".","4","1","9",".",".","5"],
 [".",".",".",".","8",".",".","7","9"]
]
输出: false

解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```
```markdown
说明:
一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
给定数独序列只包含数字 1-9 和字符 '.' 。
给定数独永远是 9x9 形式的。
```
### 我的思路
1. 这道题是一个典型的hash表的题目，从题目中我们可以看出，有三点我们是需要满足的：
  * 数字 1-9 在每一行只能出现一次。
  * 数字 1-9 在每一列只能出现一次。
  * 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
那么，我们根据上面的三条规则，我们给每一行、每一列、每一个3X3宫都维护一个hash表（这样可以用空间来换时间）。
2. 在维护了所有的hash表之后，我们将数独进行遍历，然后判断每一个元素是在哪一行、哪一列和哪一个宫格之内，然后将hash表中对应元素的出现次数进行修改。
3. 最后，判断每一行、每一列和每一个宫格中对应的元素出现的次数是否大于1，如果大于1，则不满足要求。

### Python代码
```python
    def findSubstring1(self, s: str, words: list) -> list:
        from collections import Counter
        colomn = []
        row = []
        spare = []
        for i in range(9):
            colomn.append(Counter())
            row.append(Counter())
            spare.append(Counter())
        for i in range(9):
            for j in range(9):
                num = board[i][j]
                if num != '.':
                    num = int(num)
                    spare_num = (i // 3) * 3 + (j // 3) #这个是判断相应元素在哪个宫格之中的方法
                    spare[spare_num][num] += 1
                    row[i][num] += 1
                    colomn[j][num] += 1
                    if spare[spare_num][num] > 1 or row[i][num] > 1 or colomn[j][num] > 1:
                        return False
        return True
```

